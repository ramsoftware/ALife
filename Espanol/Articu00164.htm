<!DOCTYPE HTML>
<html>
	<head>
		<link href="../Estilo.css" rel="stylesheet" type="text/css" />
		<title>Hipótesis: Apuntes de Vida Artificial</title>
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<meta name="description" content="Hipótesis: Apuntes de Vida Artificial"/>
		<meta name="keywords" content="Vida Artificial, Hipótesis"/>
		<meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
	</head>
	
	<body>
		<header>
			<p><a href="../index.html">Ir a Inicio</a></p>
			<h1>Hipótesis: Apuntes de una clase sobre Inteligencia Artificial en el que trata el tema de la Vida Artificial. <time>2007-marzo-20</time></h1>
		</header>

		<section>
			<article>
				<p>Estoy haciendo una Maestría en Ingeniería con énfasis en Ingeniería de Sistemas y ahora estamos viendo una cátedra sobre computación inteligente. El tema que trato a continuación es sobre lo visto en el tema de Vida Artificial. En letra normal lo visto en el curso (diapositivas) y en letra cursiva mis comentarios.</p>
				<p><b>1.</b> Comportamiento emergente: Al interactuar entre si entidades similares con comportamiento muy simple, puede surgir un comportamiento mucho más complejo que no estaba programado en las entidades simples (hormigas, dilemas sociales, etc.)<br /> <i>Por ejemplo cuando las aves emigran logran hacer la característica figura triangular en el aire para minimizar el frenado del aire (una figura aerodinámica), o los cardúmenes que se mueven al unísono. Son comportamientos de grupo, de manada, de enjambre, de colonia. El todo es más que la suma de las partes. Determinados miembros se especializan o se dedican a una tarea exclusivamente y las otras tareas que requieren para sobrevivir son hechas por otros miembros. El inicio de una simbiosis, pero en entes similares.</i></p>
 				<p><b>2.</b> La inteligencia se basa en predecir el futuro, anticiparlo, adaptarse y sobrevivir.<br /> <i>En el libro del "el cerebro y el mito del yo", el autor anota que la capacidad de predecir es de seres con capacidad para desplazarse de su entorno porque deben predecir sus movimientos (por ejemplo, para eludir una roca en el camino) y ese es el inicio de la inteligencia.</i></p>
 				<p><b>3.</b> La Teoría de la Evolución también evoluciona <i>(más bien se complementa o se amplía).</i><br /> Charles Darwin (Darwinismo) = Selección del más apto.<br /> a. Competencia.<br /> b. Lucha (gana el más fuerte)<i>&iexcl;&iexcl;no!! es el más apto.</i><br /> c. Ambiente cruel porque sobrevive el más fuerte. <i>¿Ambiente cruel? no siempre, y repito: &iexcl;sobrevive el más apto!.</i></p>
 				<p>NeoDarwinismo = Darwinismo + Teoría de Juegos<br /> a. La competencia sigue existiendo, pero la cooperación es más importante.<br /> b. Sobreviven los que se apoyan mutuamente entre si y crean nuevas estructuras (como las células eucariotas, seres multicelulares, grupos sociales)<i>, es lo que sostengo con la simbiosis y mi hipótesis del macroorganismo<br /></i> c. El mundo lo fabrica y lo domina el más inteligente. <i>¿Dominio? déjame dudar un poco, la inteligencia es solo una más de las estrategias de la vida para sobrevivir, pero que sea el fin último, no creo. Si este se vuelve un ambiente muy hostil, dudo que dure mucho el ser humano, en cambio, sobrevivirán las bacterias extremófilas (no inteligentes, pero si les sacan provecho a ambientes hostiles)</i></p>
 				<p><b>4.</b> Sistemas evolutivos:<br /> a. Población (conjunto) de entes.<br /> b. Se reproducen (sexual o asexualmente).<br /> c. Con variabilidad (por el cruce sexual o por mutaciones).<br /> d. Sometidos a una presión selectiva (comparten un recurso vital escaso).</p>
 				<p><b>5.</b> ¿Por qué se necesita variabilidad?<br /> Si todos los entes son iguales, hay estancamiento <i>(¿y el comportamiento emergente?)</i>. las teorías evolutivas actuales hablan de equilibrios puntuales (la evolución no es continua sino a saltos). Actualmente estamos en un punto de "estancamiento" <i>(no me lo creo, inclusive la explosión cámbrica requirió millones de años).</i></p>
 				<p><b>6.</b> La humanidad exhibe tres niveles de evolución <i>(¿solo la especie humana? no lo creo).</i><br /> a. ontogenética (dentro del individuo). La mínima unidad es la neurona. El depósito es el conocimiento.<br /> b. philogenética (el linaje). La mínima unidad son los genes. El depósito es el genoma.<br /> c. sociogenética (la sociedad). La mínima unidad son las ideas. El depósito es la cultura.</p>
 				<p><b>7.</b> ADN compuesto de Adenina, Timina, Guanina, Citosina (ATCG). 3 nucleótidos = codon. codón se traduce en aminoácido, aminoácidos son los bloques de las proteínas. Las proteínas se comportan dependiendo de sus estructuras 3D y son las que generan al individuo (forma y funcionamiento). Hay codones que son marcas de finalización. La sucesión de codones es un gen.<br /> Al ADN se le llama genotipo, la forma y funcionamiento se le llama fenotipo. Pasar de genotipo a fenotipo se llama expresión.</p>
 				<p><b>8.</b> En computación evolutiva hay un solo cromosoma muy largo. No hay expresión. El fenotipo y el genotipo es lo mismo. Un gen produce UNA sola característica en el fenotipo. En biología un gen puede producir varias características del fenotipo o un fenotipo es el resultado de la interacción de varios genes.</p>
 				<p><b>9.</b> Los algoritmos determinísticos (los clásicos) son muy eficientes, pero poco generalizan y caso contrario, entre más aleatorio (sea el algoritmo), más genérico es, pero son poco eficientes. La computación evolutiva trata de ponerse en el medio.</p>
 				<p><b>10.</b> Algoritmos genéticos: Búsqueda de óptimos, muy robusto, basado en el concepto de la evolución. Sirven principalmente para problemas numéricos. Búsqueda orientada. Soluciones múltiples. Problemas generales. Aplicaciones: Minimización/Maximización de funciones multidimensionales, descubrimiento de estrategias óptimas en juegos.</p>
 				<p><b>11.</b> Diseño de un algoritmo genético<br /> a. Definir un cromosoma (secuencia de símbolos)<br /> &nbsp;&nbsp;&nbsp; . Cada gen del cromosoma almacena un símbolo<br /> &nbsp;&nbsp;&nbsp; . Cada gen puede tener varios alelos.<br /> &nbsp;&nbsp;&nbsp; . Un cromosoma debe representar TODAS las posibles soluciones al problema.<br /> &nbsp;&nbsp;&nbsp; . La posición de cada gen debe definir alguna característica relevante a la solución.<br /> b. Definir una función de evaluación (<i>la selección natural</i>).<br /> c. Definir los operadores de reproducción.<br /> d. Definir la forma sobre como los nuevos cromosomas reemplazarán los viejos.<br /> e. Definir la manera de normalizar la función de evaluación para conseguir la función de aptitud. <i>(Esto lo entiendo sobre como evalúo cuantitativamente la adaptación del algoritmo genético dada la función de selección, porque, aunque varios organismos pasan la prueba de la selección natural, algunos les van mejor que a otros y a los que les va mejor son los que tienen mayores posibilidades de reproducirse)</i></p>
 				<p><b>12.</b> Funcionamiento de un algoritmo genético<br /> a. Generar una población de N cromosomas al azar (típicamente N=100) <i>Hay que hacer pruebas si una población más grande que ese valor sería mejor.</i><br /> b. Evaluar cada cromosoma usando la función de aptitud <i>(deseche los que no pasaron y evalúe a los que si pasaron)<br /></i> c. Seleccionar un subconjunto de cromosomas dependiendo de su aptitud y pasarlos a la "matting pool" <i>(los mejores pasan a la "sala VIP" para ser reproducidos).</i><br /> d. Reproducir los cromosomas de la "matting pool" utilizando ciertos operadores (cruzamiento, mutaciones).<br /> e. Reemplazar los viejos cromosomas por los nuevos (usualmente manteniendo constante el número N de cromosomas). <i>(Pero en la naturaleza las especies exitosas tienden a crecer, hay que hacer pruebas)</i>. Hay políticas generacionales: Puede ser un reemplazo total de los padres <i>(no muy recomendado)</i> o eliminando los peores padres. Hay políticas de estado estacionario: No hay "matting pool" solo se adiciona un nuevo individuo por selección de unos determinados padres <i>(eso sí que es más cercano a la naturaleza).</i><br /> f.&nbsp; Repetir (volver a b.) hasta que se estabilice la solución. <i>(la naturaleza nunca termina).</i></p>
 				<p><b>Detalles de la función de evaluación (fi)<br /></b> a. Un indicador de lo bueno que es el cromosoma.<br /> b. Debe ser rápido para evaluarse.</p>
 				<p><b>Detalles de la función de aptitud (Ui)</b><br /> a. Es la función de evaluación dividida por el máximo esperado de ella Ui=fi/fmax<br />b. Hay que normalizarla entre [0,1]</p>
 				<p>Para seleccionar los cromosomas que pasan a la "matting pool" se tiene en cuenta el resultado de la función de aptitud de cada uno y esto se le aplica una distribución de probabilidad para saber cuáles serán los escogidos. Puede ser por:<br /> . Sorteo: Cada puesto de la "matting pool" es rifado (dándole más probabilidad al mejor). <i>Consume una cantidad K de números aleatorios=tamaño de la piscina.</i><br /> . Ruleta <i>(la típica distribución empírica)<br /> .</i> Por Restos: Los mejores entran a la piscina y las vacantes se rifan usando los métodos anteriores.<br /> . Por torneo: Se seleccionan tres cromosomas al azar y se escoge el mejor. Así hasta que complete la piscina. Es el más rápido.</p>
 				<p><b>13.</b> Los "peros" de los algoritmos genéticos:<br /> a. NO hay, NI habrá seguridad teórica que el algoritmo genético vaya a converger, ni que llegue a la mejor solución.<br /> b. Al diseñar debe tener en cuenta la completitud (cada solución se puede codificar en el cromosoma), <i>es decir, no se puede dejar nada por fuera</i>, la cerradura (cada cromosoma equivale a una solución), <i>la solución encontrada debe ser viable.<br /></i> c. Y preferiblemente los cromosomas deben presentar uniformidad (todas las soluciones deben estar representadas por la misma cantidad de cromosomas), localidad (un pequeño cambio al cromosoma solo hace un pequeño cambio al resultado). <i>Lo último si es difícil de lograr sobre todo en la programación genética que estoy desarrollando.<br /></i> d. Como la solución se codifica en bits, si escoge un tamaño pequeño en la cadena de bits deja por fuera soluciones, si escoge un tamaño grande de la cadena de bits se cuelan soluciones no viables. <i>Resolver esto no es sencillo.<br /></i> e. Mantener la diversidad (los superpadres que generan hijos que finalmente consumen toda la población), evolución errática en las últimas generaciones <i>(no me ha sucedido en las simulaciones).<br /></i> f. La epistasis: <i>un gen genera individuos muy buenos, pero no tan buenos, pero la selección no logra deshacerse de ese gen.<br /></i> g. Mínimo local (convergen muy rápido).</p>
 				<p><b>14.</b> Como minimizar los problemas de los algoritmos genéticos:<br /> a. Aumentar la población de cromosomas.<br /> b. Mantener la diversidad de los cromosomas.<br /> c. Controlar la presión selectiva.<br /> d. Islas <i>(Charles Darwin lo dedujo)</i><br /> e. Controlar las edades de los individuos <i>(interesante forma de deshacerse de los superindividuos pero echa por la borda una estrategia de la naturaleza que es la longevidad)</i>.<br /> f. Reiniciar todo, salvando los mejores <i>(¿un diluvio y un arca de Noe?)</i></p>
 				<p><b>15.</b> Criterios de terminación: por número de ejecuciones <i>(pésimo)</i>, convergido en un porcentaje, si el cambio de una generación a otra está por debajo de un porcentaje.</p>
 				<p><b>16.</b> Típicos parámetros en una simulación con algoritmos genéticos:<br /> a. Población: Entre 50 y 100 cromosomas <i>(yo los llamo entre 50 y 100 organismos)</i><br /> b. Longitud del cromosoma: Depende del problema.<br /> c. Probabilidad de cruce: 20% a 60% por cromosoma.<br /> d. Probabilidad de mutación: 0.1% a 5% por gen.<br /> <b><br /> 17.</b> Los parámetros anteriores pueden ajustarse con otro algoritmo genético, se codifican en cromosomas esos parámetros e igual se evalúan como cualquier algoritmo genético ¿La función de aptitud? Depende como con esos parámetros les va en las simulaciones de algoritmos genéticos.&nbsp; <i>(si era un problema que tenía, los parámetros son ajustados por el usuario en el archivo de inicialización, esta es una buena idea, pero consume mucho tiempo de cómputo)</i></p>
 				<p><b>18. Programación Genética<br /></b> Es la misma que he estado haciendo desde el capítulo 2 solo que Koza su fundador representa los algoritmos como si fuesen árboles (igual que un evaluador de expresiones basados en árboles). La mutación son cambios en las ramas del árbol.</p>
 				<p>Se deben cumplir las condiciones de suficiencia (cada solución se puede codificar en el cromosoma) y cerradura (cada cromosoma equivale a una solución).</p>
 				<p>Hay que tener especial cuidado cuando se codifican funciones en el que se debe tener en cuenta el número de parámetros y el tipo de parámetros.</p>
 				<p><b>Para Iniciar (hay que recordar que se representan como árboles)<br /></b> 1. "Full" Crear los programas con todo el camino L completo.<br /> 2. "Grow" Se crean los programas de tamaño variable.<br /> 3. "Ramped half and half" Se define un porcentaje de probabilidad por cada tamaño entre 2 y L (y este es el que da mejor diversidad). <i>Excelente idea para evitar superpadres.</i></p>
 				<p><b>Operadores de reproducción<br /></b> Cruce: Intercambiar dos sub-arboles al azar entre dos individuos.<br /> Mutación: Eliminar al azar un sub-árbol y reemplazarla con otro.<br /> Permutación: Similar al cruce, pero dentro del mismo individuo.<br /> Edición: Eliminar bloques inútiles.<br /> Encapsulación: Cambiar toda una función por otra</p>
 				<p>Los problemas:<br /> a. Mucho poder de cómputo.<br /> b. Mucho código basura (intrones)<br /> c. Las funciones primitivas deben estar orientadas a la solución. Si sobran genera código inútil, si faltan se pierden posibilidades de solución. <i>Es como cuando uno toma la decisión de usar funciones como seno, coseno, tangente o solo operaciones básicas.</i></p>
 				<p>Para diseñar:<br /> a. Funciones a usar.<br /> b. ¿Uso de bucles?<br /> c. Número de variables internas (y si va a usar arreglos unidimensionales o N-dimensionales).<br /> d. ¿Uso de constantes?</p>
 				<p>Aplicaciones:<br /> a. Regresión simbólica <i>(lo que vengo haciendo desde el capítulo 2).</i><br /> b. Predicción de secuencias.<br /> c. Diseño en Ingeniería<br /> d. Estrategia en robots.<br /> e. Diseño de circuitos digitales.<br /> f. Demostración de identidades matemáticas.<br /> g. Comportamiento emergente.<br /> h. Clasificación de datos.<br /> i. Diseño de controladores y automatismos (parquear un camión articulado).<br /> j. Diseño de estrategias óptimas en videojuegos.</p>
 				<p><b>19.</b> Evolución Gramatical<br /> Codifican instrucciones en una tupla tipo NTPS (N símbolos no terminales, T símbolos terminales, P conjunto de reglas de producción, S símbolo inicial). <i>Es lo último que estoy haciendo, en el que codifico una instrucción en un número entero.</i><br /> La teoría de la evolución neutral de Kimura dice que las mutaciones silenciosas (las que afectan a instrucciones no ejecutadas) son las responsables de la gran diversidad genética que hay.<br /> <b><br /> 20.</b> Programación por expresión genética<br /> Es el capítulo 1 donde son ecuaciones representadas por un árbol (el típico evaluador de expresiones) y van ejecutándose de igual manera que un algoritmo genético. Los árboles formados se recorren por niveles y eso da origen a la expresión horizontal del cromosoma.<br /> <br /> <b>21.</b> Programación Evolutiva<br /> No hay una codificación fija (como la binaria que tiene que ser cromosoma), sino que se puede codificar dependiendo de como lo necesite el problema (árboles, máquinas de estado finito, etc..). No hay operador de cruce sino de mutación.</p>
 				<p><b>22.</b> Estrategias evolutivas<br /> El famoso ejemplo de diseñar un ala de avión utilizando estrategias evolutivas (Schwefel y Bienert en Berlín en 1963). Reproducción con mutación. Estrategias como reemplazo total de los padres o competencia padre vs hijos</p>
 				<p><b>23.</b> Sistemas clasificadores<br /> Se basan en puros IF condicionales: IF condicion THEN hacer, la condición y el hacer son deducidos por evolución, se evalúa cada IF y se recompensa si la acción fue adecuada.</p>
 				<p><b>24.</b> Simulated Annealing<br /> Es una metaheurística para problemas de optimización global, es decir, encontrar una buena aproximación al óptimo global de una función en un espacio de búsqueda grande. El concepto es análogo a calentar un metal y enfriarlo con la esperanza de que en este proceso repetitivo los átomos se acomoden en las posiciones de menor energía, si un átomo queda mal ubicado será fácil de desprender de la lámina por otros átomos por su poca fuerza de cohesión.</p>
			</article>
		</section>
	</body>
</html>
