<!DOCTYPE HTML>
<html lang="es">
<head>
    <meta charset="utf-8">
	<link href="../Estilo.css" rel="stylesheet" type="text/css" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/css/bootstrap.min.css"
          integrity="sha384-rbsA2VBKQhggwzxH7pPCaAqO46MgnOM80zW1RWuH61DGLwZJEdK2Kadq2F9CUG65" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/js/bootstrap.bundle.min.js"
            integrity="sha384-kenU1KFdBIe4zVF0s0G1M5b4hcpxyD9F7jL+jjXkk+Q2h455rYXK/7HAuoJl+0I4"
            crossorigin="anonymous"></script>
    <title>Colaboración entre individuos. Programa 29.</title>
</head>
<body>
<div class="container-fluid">
	<div class="row">
		<div class="col">
			<header>
				<p><a href="../index.html">Ir a Inicio</a></p>
				<h1>Colaboración entre individuos</h1>
				<h2>Programa 29. Nuevo software para comparar redes neuronales y algoritmos evolutivos.</h2>
			</header>
			<p>Dada una serie de datos (X, Y) donde X no se repite, se busca la expresión Y = F(X) que genere esa serie de datos.</p>
			<p>El algoritmo es el siguiente:</p>
			<p>1. Botón: Generar Dataset. Generar una ecuación al azar del tipo Y=a*SENO(b*X+c) + d*SENO(e*X+f) + ...... + p*SENO(q*X+r). Dónde a, b, c, d, e, f, ....p, q, r son valores aleatorios.</p>
			<p>2. Con esa ecuación dar origen a N valores (X, Y). X no debe repetirse.</p>
			<p>3. Normalizar los valores (X, Y)</p>
			<p>4. Un subconjunto de esos valores (X, Y) son para validar y evitar el sobre-entrenamiento.</p>
			<p>5. Botón: Procesar. Iniciar ciclo</p>
			<p>		5.1 Generar N redes neuronales y entrenarlas para dar con el patrón de esa serie (X, Y)</p>
			<p>		5.2 Generar M individuos y modificarlos (algoritmo evolutivo) para dar con el patrón de esa serie (X, Y)</p>
			<p>6. Botón: Detener. Finaliza el ciclo</p>
			<p>7. Probar cada red neuronal y ver cuál se ajusta más a los valores de validación.</p>
			<p>8. Probar cada individuo y ver cuál se ajusta más a los valores de validación.</p>
			<p>9. Mostrar los tres gráficos: valores (X, Y) generados, la mejor red neuronal y el mejor individuo.</p>
			<p><img src="../Imagen/colaborar29a.jpg"></img></p>
			<p><img src="../Imagen/colaborar29b.jpg"></img></p>
			<p>Conclusiones:</p>
			<p>Este algoritmo evolutivo ha mostrado un muy buen ajuste, pero hay que dejar que ejecute durante muchos ciclos.</p>
			<p>Cabe recordar que existe un procedimiento determinístico para hallar este tipo de funciones: <a href="https://www.youtube.com/watch?v=h7apO7q16V0">La transformada rápida de Fourier</a>, la cual encuentra las funciones que sumadas generan la función de datos del ambiente. ¡OJO! Funciona siempre y cuando el ambiente sea cíclico. El software muestra un acercamiento no determinista a la función, pero, por supuesto, lo mejor es usar la <a href="https://www.youtube.com/watch?v=h4PTucW3Rm0">Transformada de Fourier</a>.
			<p>Descargue el programa en C# <a href="../Download/colaborar29.zip">dando clic aquí.</a></p>
		</div>
	</div>
</div>
</body>
</html>
