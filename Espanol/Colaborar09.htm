<!DOCTYPE HTML>
<html>
	<head>
		<link href="../Estilo.css" rel="stylesheet" type="text/css" />
		<title>Colaboración entre individuos. Programa 9.</title>
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<meta name="description" content="Investigación sobre la colaboración entre individuos"/>
		<meta name="keywords" content="Vida Artificial, colaboración, software, simulaciones"/>
		<meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
	</head>
	
	<body>
		<header>
			<p><a href="../index.html">Ir a Inicio</a></p>
			<h1>Colaboración entre individuos</h1>
			<h2>Programa 9. Identificando los números de un reloj digital</h2>
		</header>
		<section>
		
			<article>
<p>Dado los números de un reloj digital, por ejemplo:</p>
<img src="../Imagen/Reloj1.jpg">
<p>Puede interpretarlos como 0, 1, 2, 3, 4, 5, 6, 7, 8, 9<p>
<p>Este problema se abordó en mi libro <a href="https://github.com/ramsoftware/LibroRedNeuronal2020">Redes Neuronales</a> (página 84) y fue resuelto usando un percetrón multicapa.</p>
<p>Se quiere resolver con un algoritmo genético que dado ese número al estilo reloj digital se pueda deducir el número como tal.</p>
<p>Para iniciar se pone un identificador a cada barra.</p>
<img src="../Imagen/Reloj2.jpg">
<p>Luego se le da un valor de “1” a la barra que queda en rojo al construir el número y “0” a la barra que queda en azul claro. Por ejemplo:</p>
<img src="../Imagen/Reloj3.jpg">
<p>Así se representa el dibujo de cada número de un reloj digital:</p>
<img src="../Imagen/Reloj4.jpg">
<p>En código fuente</p>
<p>           Entradas = new int[][] {<br>
                new int[] { 1, 1, 1, 0, 1, 1, 1 }, // Número 0<br>
                new int[] { 0, 0, 1, 0, 0, 1, 0 }, // Número 1<br> 
                new int[] { 1, 0, 1, 1, 1, 0, 1 }, // Número 2<br>
                new int[] { 1, 0, 1, 1, 0, 1, 1 }, // Número 3<br>
                new int[] { 0, 1, 1, 1, 0, 1, 0 }, // Número 4<br>
                new int[] { 1, 1, 0, 1, 0, 1, 1 }, // Número 5<br>
                new int[] { 1, 1, 0, 1, 1, 1, 1 }, // Número 6<br>
                new int[] { 1, 0, 1, 0, 0, 1, 0 }, // Número 7<br>
                new int[] { 1, 1, 1, 1, 1, 1, 1 }, // Número 8<br>
                new int[] { 1, 1, 1, 1, 0, 1, 1 }  // Número 9<br>
            };<br><br>

           Valor del número en notación binaria<br>
            SalidasEsperadas = new int[][] {<br>
                new int[]  { 0, 0, 0, 0 }, //0<br>
                new int[]  { 0, 0, 0, 1 }, //1<br>
                new int[]  { 0, 0, 1, 0 }, //2<br>
                new int[]  { 0, 0, 1, 1 }, //3<br>
                new int[]  { 0, 1, 0, 0 }, //4<br>
                new int[]  { 0, 1, 0, 1 }, //5<br>
                new int[]  { 0, 1, 1, 0 }, //6<br>
                new int[]  { 0, 1, 1, 1 }, //7<br>
                new int[]  { 1, 0, 0, 0 }, //8<br>
                new int[]  { 1, 0, 0, 1 }  //9<br>
            };<br>
</p>
  
<h2>Se usa colaboración entre distintos individuos.</h2>
              <p>I. Para una población 1:<br><br>
              Significa que si se ingresa 1, 1, 1, 0, 1, 1, 1 (primer registro de entradas) se obtiene 0 (primer valor del primer registro de salidas Esperadas)<br><br>
              Si se ingresa 0, 0, 1, 0, 0, 1, 0 (segundo registro de entradas) se obtiene 0 (primer valor del segundo registro de salidas Esperadas)<br><br>
              Si se ingresa 1, 0, 1, 1, 1, 0, 1 (tercer registro de entradas) se obtiene 0 (primer valor del tercer registro de salidas Esperadas)<br><br>
              y así sucesivamente...</p><br>
              
              
              <p>II. Para una población 2:<br><br>
              Significa que si se ingresa 1, 1, 1, 0, 1, 1, 1 (primer registro de entradas) se obtiene 0 (segundo valor del primer registro de salidas Esperadas)<br><br>
              Si se ingresa 0, 0, 1, 0, 0, 1, 0 (segundo registro de entradas) se obtiene 0 (segundo valor del segundo registro de salidas Esperadas)<br><br>
              Si se ingresa 1, 0, 1, 1, 1, 0, 1 (tercer registro de entradas) se obtiene 0 (segundo valor del tercer registro de salidas Esperadas)<br><br>
              y así sucesivamente...</p><br>

              
              <p>III. Para una población 3:<br><br>
              Significa que si se ingresa 1, 1, 1, 0, 1, 1, 1 (primer registro de entradas) se obtiene 0 (tercer valor del primer registro de salidas Esperadas)<br><br>
              Si se ingresa 0, 0, 1, 0, 0, 1, 0 (segundo registro de entradas) se obtiene 0 (tercer valor del segundo registro de salidas Esperadas)<br><br>
              Si se ingresa 1, 0, 1, 1, 1, 0, 1 (tercer registro de entradas) se obtiene 1 (tercer valor del tercer registro de salidas Esperadas)<br><br>
              y así sucesivamente...</p><br>


              <p>IV. Para una población 4:<br><br>
              Significa que si se ingresa 1, 1, 1, 0, 1, 1, 1 (primer registro de entradas) se obtiene 0 (cuarto valor del primer registro de salidas Esperadas)<br><br>
              Si se ingresa 0, 0, 1, 0, 0, 1, 0 (segundo registro de entradas) se obtiene 1 (cuarto valor del segundo registro de salidas Esperadas)<br><br>
              Si se ingresa 1, 0, 1, 1, 1, 0, 1 (tercer registro de entradas) se obtiene 0 (cuarto valor del tercer registro de salidas Esperadas)<br><br>
              y así sucesivamente...</p><br>

<p>Son 4 poblaciones, cada población generará un individuo que cumpla con las salidas esperadas. Luego al juntar los 4 individuos, se interpreta el reloj digital.</p>
			</article><br>

			<article>
				<h2>Código fuente</h2>
				<p><a href="../Download/colaborar09.zip">Descargar el código fuente desarrollado en C#. Probado en Microsoft Visual Studio 2022 Community Edition</a></p>
			</article><br>
			
			<article>
				<h2>Resultados</h2>
				<p>Esta es la salida del programa. Se muestra como juntando los 4 individuos se obtiene la salida deseada<p>
				<img src="../Imagen/Reloj5.jpg">
			</article>
	
		</section>
	</body>
</html>